# CQLAIにおけるUDT(ユーザー定義型)サポート

## 概要

CQLAIには、複雑なネストされたデータ構造の適切な表示と処理を提供する、Cassandraユーザー定義型(UDT)の完全なサポートがあります。

## 実装の詳細

### 課題

Apache Cassandra gocqlドライバーv2には基本的な制限があります: コンパイル時の型情報なしでUDTカラムをスキャンすると、実際のデータの代わりに空のマップ`{}`を返します。これは、gocqlがコンパイル時に正確な構造を知らないと、UDTをGoマップにデコードしようとして失敗するためです。

### 解決策

次のような包括的なUDTサポートシステムを実装しました:

1. **gocqlの自動デコードをバイパス** - `UnmarshalCQL`インターフェースを実装するカスタム`RawBytes`型を使用
2. **生のバイナリデータを抽出** - UDTカラムのためにCassandraから直接
3. **バイナリプロトコルデコーダーを実装** - スキーマ情報を使用して生のバイトを適切にデコード
4. **UDT定義をロード** - Cassandraのシステムテーブル(`system_schema.types`と`system_schema.columns`)から
5. **再帰的にデコード** - コレクション内のUDTやUDT内のコレクションを含むネストされた構造

## コンポーネント

### 1. 型パーサー(`internal/db/type_parser.go`)
`frozen<address>`や`list<frozen<map<text, frozen<address>>>>`のようなCQL型文字列を構造化された型情報に解析します。

### 2. UDTスキーマローダー(`internal/db/udt_schema.go`)
- `system_schema.types`からUDT定義をロード
- パフォーマンスのために定義をキャッシュ
- UDTメタデータへのスレッドセーフなアクセスを提供

### 3. バイナリデコーダー(`internal/db/udt_decoder.go`)
- Cassandraのバイナリプロトコル形式をデコード
- すべてのCQLネイティブ型を処理
- ネストされた構造を再帰的にデコード
- null値とフィールドを適切に処理

### 4. 生バイトスキャナー(`internal/db/raw_bytes.go`)
- `UnmarshalCQL`を実装するカスタム型
- gocqlがデコードする代わりに生のバイトをキャプチャ
- gocqlの壊れたUDTデコードをバイパスするために不可欠

### 5. クエリ結果の拡張
- UDTカラムを検出するために`ExecuteSelectQuery`を変更
- UDTカラムに`RawBytes`を使用するようにストリーミング結果ハンドラーを拡張
- クエリからキースペースとテーブルを自動検出

## サポートされる機能

✅ **シンプルなUDT**: 基本的なユーザー定義型の表示
✅ **フローズンUDT**: フローズンUDTカラムの適切な処理
✅ **ネストされたUDT**: 他のUDTを含むUDT
✅ **UDTのコレクション**: UDT値を含むリスト、セット、マップ
✅ **コレクションを含むUDT**: コレクションフィールドを含むUDT
✅ **NULL処理**: nullのUDTフィールドの適切な表示
✅ **複数のキースペース**: クロスキースペースUDT参照をサポート
✅ **COPYコマンド**: CSVファイル内のJSONとしてUDTデータをエクスポート/インポート
✅ **タブ補完**: UDTカラムのフィールドレベル補完

## 使用例

### UDTの作成

```sql
CREATE TYPE address (
    street text,
    city text,
    state text,
    zip_code text,
    country text
);

CREATE TABLE users (
    user_id uuid PRIMARY KEY,
    name text,
    home_address frozen<address>,
    work_address frozen<address>
);
```

### UDTデータのクエリ

```sql
SELECT * FROM users;
```

CQLAIでの出力:
```
┌──────────────────────────────────────┬──────────┬──────────────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────┐
│ user_id (PK)                         │ name     │ home_address                                                     │ work_address                                                     │
├──────────────────────────────────────┼──────────┼──────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────┤
│ 123e4567-e89b-12d3-a456-426614174000 │ John Doe │ {street: 123 Main St, city: New York, state: NY, zip_code:       │ {street: 456 Work Ave, city: New York, state: NY, zip_code:      │
│                                      │          │ 10001, country: USA}                                             │ 10002, country: USA}                                             │
└──────────────────────────────────────┴──────────┴──────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────┘
```

### UDTでのCOPY TO

```sql
COPY users TO 'users.csv' WITH HEADER=true;
```

UDTデータは、簡単な再インポートのためにCSVファイル内でJSONとしてエクスポートされます。

### DESCRIBE TYPE

```sql
DESCRIBE TYPE address;
```

すべてのフィールドとその型を含む完全なUDT定義を表示します。

## 技術的注意事項

### バイナリプロトコル

CassandraのバイナリプロトコルにおけるUDTデータは次のようにエンコードされます:
- 4バイト: フィールド長(int32)
- Nバイト: フィールドデータ
- 定義順序で各フィールドに繰り返し
- nullフィールドは-1の長さで示されます

### パフォーマンスに関する考慮事項

- UDTスキーマは繰り返しクエリを避けるためにキースペースごとにキャッシュされます
- バイナリデコードはオンデマンドで実行されます
- 生バイト抽出は最小限のオーバーヘッドです

## 既知の制限

1. **バッチモードJSON出力**: 現在、バッチモードのJSON出力でUDTの空のオブジェクトを表示します。対話モードは正しく動作します。
2. **フィールドの順序**: UDTフィールドは、内部マップ実装に応じて異なる順序で表示される場合があります。
3. **大きなUDT**: 多くのフィールドを持つ非常に大きなUDTは、表示フォーマットに影響を与える可能性があります。

## 将来の拡張

- [ ] バッチモードのJSON出力でUDTを改善
- [ ] UDTフィールドの順序保持を追加
- [ ] UDTの変更とスキーマの進化のサポート
- [ ] 大きなUDTコレクションのパフォーマンス最適化
