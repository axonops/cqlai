name: Release Linux/Windows

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag name for release (e.g., v1.0.0)'
        required: true
        default: 'v0.1.0'

env:
  GO_VERSION: '1.25'
  GCP_PROJECT: axonops-public
  GCP_REGION: europe
  APT_REPO: axonops-apt
  YUM_REPO: axonops-yum
  DOCKER_REPO: axonops-docker
  IMAGE_NAME: cqlai

jobs:
  # Security scan before release
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Run gosec security scanner
        run: |
          go install github.com/securego/gosec/v2/cmd/gosec@v2.23.0
          gosec -no-fail -fmt sarif -out gosec-results.sarif ./...

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.34.0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Check for critical vulnerabilities
        run: |
          if [ -f trivy-results.sarif ]; then
            # Parse SARIF to check for critical issues
            critical_count=$(jq '.runs[0].results | length' trivy-results.sarif)
            if [ "$critical_count" -gt "0" ]; then
              echo "❌ Found $critical_count critical/high vulnerabilities"
              jq '.runs[0].results[].message.text' trivy-results.sarif
              exit 1
            fi
          fi
          echo "✅ Security scan passed"

  # Build binaries for all platforms
  build-binaries:
    name: Build ${{ matrix.platform }}
    runs-on: ubuntu-latest
    needs: security-scan  # Only build if security scan passes
    
    strategy:
      matrix:
        include:
          - platform: linux-amd64
            goos: linux
            goarch: amd64
          - platform: linux-arm64
            goos: linux
            goarch: arm64
          - platform: windows-amd64
            goos: windows
            goarch: amd64
            ext: .exe

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Get version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          elif [[ -n "${{ github.event.inputs.tag_name }}" ]]; then
            VERSION=${{ github.event.inputs.tag_name }}
          else
            VERSION="dev-${GITHUB_SHA::8}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          OUTPUT_NAME="cqlai-${{ matrix.platform }}${{ matrix.ext }}"
          go build -trimpath -ldflags="-s -w -buildid= -X main.Version=${{ steps.version.outputs.version }}" \
            -o "${OUTPUT_NAME}" \
            ./cmd/cqlai
          
          # Make executable on Unix systems
          if [ "${{ matrix.goos }}" != "windows" ]; then
            chmod +x "${OUTPUT_NAME}"
          fi

      - name: Package binary
        run: |
          OUTPUT_NAME="cqlai-${{ matrix.platform }}${{ matrix.ext }}"
          # Only create tar.gz for Linux (Windows and macOS installers will be created in separate jobs)
          if [ "${{ matrix.goos }}" = "linux" ]; then
            tar czf "cqlai-${{ matrix.platform }}.tar.gz" \
              --owner=0 --group=0 \
              "${OUTPUT_NAME}" README.md LICENSE
          fi

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.platform }}
          path: |
            cqlai-${{ matrix.platform }}${{ matrix.ext }}
            cqlai-${{ matrix.platform }}.tar.gz
          if-no-files-found: ignore

  # Build Windows MSI packages
  build-windows-packages:
    name: Build Windows MSI Package
    runs-on: windows-latest
    needs: build-binaries
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download binary artifact
        uses: actions/download-artifact@v4
        with:
          name: binary-windows-amd64

      - name: Get version
        id: version
        shell: bash
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=${{ github.event.inputs.tag_name }}
          fi
          # Remove 'v' prefix for package version
          PACKAGE_VERSION="${VERSION#v}"
          # MSI requires x.x.x.x format - convert RC/beta/alpha suffixes
          # e.g., 0.1.2rc1 -> 0.1.2.1, 0.1.2beta3 -> 0.1.2.3, 0.1.2 -> 0.1.2
          if [[ "$PACKAGE_VERSION" =~ ^([0-9]+\.[0-9]+\.[0-9]+)(rc|beta|alpha)([0-9]+)$ ]]; then
            MSI_VERSION="${BASH_REMATCH[1]}.${BASH_REMATCH[3]}"
          else
            MSI_VERSION="${PACKAGE_VERSION}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "package_version=${PACKAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "msi_version=${MSI_VERSION}" >> $GITHUB_OUTPUT

      - name: Sign windows binary
        shell: pwsh
        run: |
          dotnet tool install --no-cache --global AzureSignTool --version 6.0.1
          azuresigntool.exe sign --verbose -kvs  "${{ secrets.AZURE_CLIENT_SECRET }}" -kvt ${{ secrets.AZURE_TENANT_ID }} -kvu ${{ secrets.AZURE_KEY_VAULT_URI }} -kvi "${{ secrets.AZURE_CLIENT_ID }}" -kvc ${{ secrets.AZURE_KEYVAULT_CERT_NAME }} -td sha256 -tr http://timestamp.digicert.com -v cqlai-windows-amd64.exe

      - name: Install WiX Toolset
        shell: pwsh
        run: |
          # Download and install WiX Toolset
          Invoke-WebRequest -Uri "https://github.com/wixtoolset/wix3/releases/download/wix3112rtm/wix311-binaries.zip" -OutFile wix.zip
          Expand-Archive -Path wix.zip -DestinationPath wix
          echo "$PWD\wix" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Create MSI package
        shell: pwsh
        run: |
          $VERSION = "${{ steps.version.outputs.package_version }}"
          $MSI_VERSION = "${{ steps.version.outputs.msi_version }}"

          # Create WiX source file
          @"
          <?xml version='1.0' encoding='windows-1252'?>
          <Wix xmlns='http://schemas.microsoft.com/wix/2006/wi'>
            <Product Name='CQLAI' Id='*' UpgradeCode='12345678-1234-1234-1234-123456789012'
              Language='1033' Codepage='1252' Version='$MSI_VERSION' Manufacturer='AxonOps'>
              <Package Id='*' Keywords='Installer' Description='CQLAI Installer'
                Manufacturer='AxonOps' InstallerVersion='200' Languages='1033'
                Compressed='yes' SummaryCodepage='1252' Platform='x64' />
              <Media Id='1' Cabinet='cqlai.cab' EmbedCab='yes' />
              <Directory Id='TARGETDIR' Name='SourceDir'>
                <Directory Id='ProgramFiles64Folder'>
                  <Directory Id='INSTALLDIR' Name='CQLAI'>
                    <Component Id='MainExecutable' Guid='*' Win64='yes'>
                      <File Id='CqlaiExe' Source='cqlai-windows-amd64.exe' Name='cqlai.exe' KeyPath='yes' />
                      <Environment Id='PATH' Name='PATH' Value='[INSTALLDIR]' Permanent='no' Part='last' Action='set' System='yes' />
                    </Component>
                  </Directory>
                </Directory>
              </Directory>
              <Feature Id='Complete' Level='1'>
                <ComponentRef Id='MainExecutable' />
              </Feature>
            </Product>
          </Wix>
          "@ | Out-File -FilePath cqlai.wxs -Encoding UTF8

          # Compile and link
          candle.exe cqlai.wxs
          light.exe -out cqlai-$VERSION-amd64.msi cqlai.wixobj

      - name: Sign MSI package
        shell: pwsh
        run: |
          $VERSION = "${{ steps.version.outputs.package_version }}"
          azuresigntool.exe sign --verbose -kvs  "${{ secrets.AZURE_CLIENT_SECRET }}" -kvt ${{ secrets.AZURE_TENANT_ID }} -kvu ${{ secrets.AZURE_KEY_VAULT_URI }} -kvi "${{ secrets.AZURE_CLIENT_ID }}" -kvc ${{ secrets.AZURE_KEYVAULT_CERT_NAME }} -td sha256 -tr http://timestamp.digicert.com -v cqlai-$VERSION-amd64.msi

      - name: Upload MSI artifact
        uses: actions/upload-artifact@v4
        with:
          name: windows-msi
          path: "*.msi"

  # Build DEB and RPM packages
  build-packages:
    name: Build DEB/RPM ${{ matrix.arch }}
    runs-on: ubuntu-latest
    needs: security-scan  # Only build if security scan passes
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'

    strategy:
      matrix:
        include:
          - arch: amd64
            goarch: amd64
            debarch: amd64
            rpmarch: x86_64
          - arch: arm64
            goarch: arm64
            debarch: arm64
            rpmarch: aarch64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Get version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=${{ github.event.inputs.tag_name }}
          fi
          # Remove 'v' prefix for package version
          PACKAGE_VERSION="${VERSION#v}"
          # For DEB/RPM: convert RC/beta/alpha to ~ separator (proper pre-release sorting)
          # e.g., 0.1.2rc1 -> 0.1.2~rc1
          DEB_VERSION=$(echo "${PACKAGE_VERSION}" | sed 's/\(rc\|beta\|alpha\)/~\1/')
          # For RPM: pre-release goes in Release field, Version stays numeric
          # e.g., 0.1.2rc1 -> version=0.1.2, rpm_release=0.1.rc1
          if [[ "$PACKAGE_VERSION" =~ ^([0-9]+\.[0-9]+\.[0-9]+)(rc|beta|alpha)([0-9]+)$ ]]; then
            RPM_VERSION="${BASH_REMATCH[1]}"
            RPM_RELEASE="0.1.${BASH_REMATCH[2]}${BASH_REMATCH[3]}"
          else
            RPM_VERSION="${PACKAGE_VERSION}"
            RPM_RELEASE="1"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "package_version=${PACKAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "deb_version=${DEB_VERSION}" >> $GITHUB_OUTPUT
          echo "rpm_version=${RPM_VERSION}" >> $GITHUB_OUTPUT
          echo "rpm_release=${RPM_RELEASE}" >> $GITHUB_OUTPUT

      - name: Build binary
        run: |
          CGO_ENABLED=0 GOOS=linux GOARCH=${{ matrix.goarch }} go build -trimpath \
            -ldflags="-s -w -buildid= -X main.Version=${{ steps.version.outputs.version }}" \
            -o cqlai \
            ./cmd/cqlai

      - name: Install packaging tools
        run: |
          sudo apt-get update
          sudo apt-get install -y rpm dpkg-dev

      - name: Create DEB package
        run: |
          VERSION="${{ steps.version.outputs.deb_version }}"
          ARCH="${{ matrix.debarch }}"
          PKG_VERSION="${{ steps.version.outputs.package_version }}"

          # Create debian package structure
          mkdir -p cqlai-deb/DEBIAN
          mkdir -p cqlai-deb/usr/bin
          mkdir -p cqlai-deb/usr/share/doc/cqlai

          # Copy files
          cp cqlai cqlai-deb/usr/bin/
          chmod 755 cqlai-deb/usr/bin/cqlai
          cp README.md LICENSE cqlai-deb/usr/share/doc/cqlai/

          # Set ownership to root:root
          sudo chown -R root:root cqlai-deb/usr

          # Create control file
          cat > cqlai-deb/DEBIAN/control << EOF
          Package: cqlai
          Version: ${VERSION}
          Section: database
          Priority: optional
          Architecture: ${ARCH}
          Maintainer: AxonOps <support@axonops.com>
          Description: AI-powered Cassandra CQL Shell
           Modern interactive terminal for Apache Cassandra with AI assistance
          Homepage: https://github.com/axonops/cqlai
          EOF

          # Build package
          dpkg-deb --build cqlai-deb
          mv cqlai-deb.deb cqlai_${PKG_VERSION}_${ARCH}.deb

      - name: Create RPM package
        run: |
          VERSION="${{ steps.version.outputs.rpm_version }}"
          RELEASE="${{ steps.version.outputs.rpm_release }}"
          ARCH="${{ matrix.rpmarch }}"

          # Setup RPM build tree
          mkdir -p ~/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}

          # Create source tarball
          mkdir cqlai-${VERSION}
          cp cqlai README.md LICENSE cqlai-${VERSION}/
          tar czf ~/rpmbuild/SOURCES/cqlai-${VERSION}.tar.gz \
            --owner=0 --group=0 \
            cqlai-${VERSION}

          # Create spec file (no BuildArch - let --target control it)
          cat > ~/rpmbuild/SPECS/cqlai.spec << EOF
          Name:           cqlai
          Version:        ${VERSION}
          Release:        ${RELEASE}%{?dist}
          Summary:        AI-powered Cassandra CQL Shell
          License:        Apache-2.0
          URL:            https://github.com/axonops/cqlai
          Source0:        cqlai-${VERSION}.tar.gz
          %global debug_package %{nil}

          %description
          Modern interactive terminal for Apache Cassandra with AI assistance

          %prep
          %setup -q

          %build
          # Binary is prebuilt for target architecture

          %install
          mkdir -p %{buildroot}/usr/bin
          install -m 0755 cqlai %{buildroot}/usr/bin/cqlai

          %files
          /usr/bin/cqlai

          %changelog
          * $(date +"%a %b %d %Y") AxonOps <support@axonops.com> - ${VERSION}-${RELEASE}
          - Release ${VERSION}
          EOF

          # Build binary RPM only with target architecture
          rpmbuild -bb --target ${ARCH} \
            --define "_topdir $HOME/rpmbuild" \
            ~/rpmbuild/SPECS/cqlai.spec

          # Copy the built RPM
          cp ~/rpmbuild/RPMS/${ARCH}/cqlai-${VERSION}-1*.rpm ./

      - name: Upload packages
        uses: actions/upload-artifact@v4
        with:
          name: packages-${{ matrix.arch }}
          path: |
            *.deb
            *.rpm

  # Build Docker image
  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: security-scan  # Only build if security scan passes
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create Dockerfile if not exists
        run: |
          if [ ! -f Dockerfile ]; then
            cat > Dockerfile << 'EOF'
          FROM golang:1.25-alpine AS builder
          
          WORKDIR /app
          COPY go.mod go.sum ./
          RUN go mod download
          
          COPY . .
          ARG VERSION=dev
          RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -trimpath \
              -ldflags="-s -w -buildid= -X main.Version=${VERSION}" \
              -o cqlai \
              ./cmd/cqlai
          
          FROM alpine:latest
          RUN apk --no-cache add ca-certificates
          WORKDIR /root/
          COPY --from=builder /app/cqlai /usr/local/bin/cqlai
          
          ENTRYPOINT ["cqlai"]
          EOF
          fi

      - name: Get version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=${{ github.event.inputs.tag_name }}
          fi
          DOCKER_TAG="${VERSION#v}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "docker_tag=${DOCKER_TAG}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for amd64
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          build-args: |
            VERSION=${{ steps.version.outputs.version }}
          tags: |
            ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT }}/${{ env.DOCKER_REPO }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.docker_tag }}
            ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT }}/${{ env.DOCKER_REPO }}/${{ env.IMAGE_NAME }}:latest
            ghcr.io/${{ github.repository }}:${{ steps.version.outputs.docker_tag }}
            ghcr.io/${{ github.repository }}:latest
          outputs: type=docker,dest=/tmp/cqlai.tar

      - name: Upload Docker image
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/cqlai.tar

  # Upload to GCP Artifact Registry and GHCR
  upload-gcp:
    name: Upload to GCP and GHCR
    needs: [build-packages, build-docker]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    permissions:
      packages: write

    steps:
      - name: Download packages (amd64)
        uses: actions/download-artifact@v4
        with:
          name: packages-amd64

      - name: Download packages (arm64)
        uses: actions/download-artifact@v4
        with:
          name: packages-arm64

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GOOGLEKEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Upload DEB packages to Artifact Registry
        run: |
          for DEB_FILE in *.deb; do
            echo "Uploading ${DEB_FILE}..."
            gcloud artifacts apt upload ${{ env.APT_REPO }} \
              --location=${{ env.GCP_REGION }} \
              --source="${DEB_FILE}" \
              --project=${{ env.GCP_PROJECT }} || echo "Warning: ${DEB_FILE} may already exist, continuing..."
          done

      - name: Upload RPM packages to Artifact Registry
        run: |
          for RPM_FILE in *.rpm; do
            echo "Uploading ${RPM_FILE}..."
            gcloud artifacts yum upload ${{ env.YUM_REPO }} \
              --location=${{ env.GCP_REGION }} \
              --source="${RPM_FILE}" \
              --project=${{ env.GCP_PROJECT }} || echo "Warning: ${RPM_FILE} may already exist, continuing..."
          done

      - name: Configure Docker for GCP
        run: |
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: Push Docker image to GCP
        run: |
          docker load --input cqlai.tar

          VERSION="${GITHUB_REF#refs/tags/}"
          if [ -z "$VERSION" ] || [ "$VERSION" = "refs/heads/main" ]; then
            VERSION="${{ github.event.inputs.tag_name }}"
          fi
          DOCKER_TAG="${VERSION#v}"

          docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT }}/${{ env.DOCKER_REPO }}/${{ env.IMAGE_NAME }}:${DOCKER_TAG}
          docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT }}/${{ env.DOCKER_REPO }}/${{ env.IMAGE_NAME }}:latest

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push Docker image to GHCR
        run: |
          VERSION="${GITHUB_REF#refs/tags/}"
          if [ -z "$VERSION" ] || [ "$VERSION" = "refs/heads/main" ]; then
            VERSION="${{ github.event.inputs.tag_name }}"
          fi
          DOCKER_TAG="${VERSION#v}"

          docker push ghcr.io/${{ github.repository }}:${DOCKER_TAG}
          docker push ghcr.io/${{ github.repository }}:latest
  
  update-homebrew:
    name: Update homebrew repository
    needs: [build-binaries, build-windows-packages, build-packages]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'

    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
          repository: axonops/homebrew-repository
          path: homebrew
          persist-credentials: true
          fetch-depth: 0
          ssh-key: ${{ secrets.BREW_SSH_KEY }}

      - name: Get version and calculate SHA256
        id: brew_info
        run: |
          # Get the version from tag or input
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=${{ github.event.inputs.tag_name }}
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

          # Download the source tarball to calculate SHA256
          TARBALL_URL="https://github.com/axonops/cqlai/archive/refs/tags/${VERSION}.tar.gz"
          curl -L -o source.tar.gz "${TARBALL_URL}"
          SHA256=$(sha256sum source.tar.gz | cut -d' ' -f1)
          echo "sha256=${SHA256}" >> $GITHUB_OUTPUT

          echo "Version: ${VERSION}"
          echo "Source SHA256: ${SHA256}"

      - name: Update Homebrew formula
        run: |
          cd homebrew

          VERSION="${{ steps.brew_info.outputs.version }}"
          SHA256="${{ steps.brew_info.outputs.sha256 }}"

          # Update the URL with new version
          sed -i "s|archive/refs/tags/v[0-9.]*\.tar\.gz|archive/refs/tags/${VERSION}.tar.gz|g" cqlai.rb

          # Update the main SHA256 hash (the line right after url)
          sed -i "/url.*archive.*tar\.gz/!b;n;s/sha256.*/  sha256 \"${SHA256}\"/" cqlai.rb

          # Update the version in ldflags
          sed -i "s/-X main.Version=[^ ]*/-X main.Version=${VERSION}/" cqlai.rb

      - name: Commit and push changes
        run: |
          set -x
          cd homebrew

          VERSION="${{ steps.brew_info.outputs.version }}"

          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          git add cqlai.rb
          git commit -m "Update cqlai to ${VERSION}" || echo "No changes to commit"
          git push origin main

  # Create GitHub Release
  create-release:
    name: Create GitHub Release
    needs: [build-binaries, build-windows-packages, build-packages]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4

      - name: Prepare release assets
        run: |
          mkdir -p release-assets

          # Collect all release files (macOS PKG files are handled by release-macos.yml)
          find . -name "*.tar.gz" -exec mv {} release-assets/ \;
          find . -name "*.deb" -exec mv {} release-assets/ \;
          find . -name "*.rpm" -exec mv {} release-assets/ \;
          find . -name "*.msi" -exec mv {} release-assets/ \;

          # Create checksums
          cd release-assets
          sha256sum * > SHA256SUMS.txt
          cd ..

      - name: Get version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=${{ github.event.inputs.tag_name }}
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: CQLAI ${{ steps.version.outputs.version }}
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, 'rc') || contains(steps.version.outputs.version, 'beta') || contains(steps.version.outputs.version, 'alpha') }}
          files: release-assets/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
